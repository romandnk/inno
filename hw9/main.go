package main

import "sync"

/*
Распишите ваше решение в отчете. Отчет может быть представлен в любом текстовом формате:
	* комментарии в коде
	* Markdown
	* latex
	* docx
	* xlsx
	* фото листа читаемого качества, читаемого почерка
*/

/*
Представлен алгоритм для определения “зеркальности” матрицы размером n на n.
Вычислите его сложность, используя изученные формулы, в качестве размера входных данных примите n.
*/

// размер входных данных: n
// основная операция: a[i][j] != a[j][i] (проверка симметричности)
// зависит ли число выполняемых операция только от размера входных данных: нет (при не совпадении мы сразу
// выйдем из функции или же при len(a[i]) != n и n=0 мы тоже выйдем)
// формула: ∑ (от i=0 до n-2) ∑ (от j=0 до n - 1) 1
// сокращенная формула: n^2

func IsReflectMatrix(a [][]int) bool {
	n := len(a)
	if n == 0 {
		return true
	}

	for i := 0; i < n-1; i++ {
		if len(a[i]) != n {
			return false
		}
		for j := 0; j < n; j++ {
			if a[i][j] != a[j][i] {
				return false
			}
		}
	}
	return true
}

/*
Представлен рекурсивный алгоритм для поиска наименьшего элемента слайса.
Вычислите его сложность, используя изученные формулы.
*/

// размер входных данных: len(a) = n
// основная операция: t <= a[len(a)-1]
// зависит ли число выполняемых операция только от размера входных данных: да (пусть кол-во операций M(n))
// рекурсивное уравнение: M(n) = M(n-1) + 1 = M(n-i)+i = M(n-n)+n (i = n) = n
// решение или порядок роста: n

func MinEl(a []int) int {
	// только для первичной проверки
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}
	t := MinEl(a[:len(a)-1])
	if t <= a[len(a)-1] {
		return t
	}
	return a[len(a)-1]
}

/*
Представлен другой рекурсивный алгоритм для поиска наименьшего элемента слайса.
Вычислите его сложность, используя изученные формулы.
Сравните эффективность алгоритма с предыдущим вариантом.
Попробуйте увеличить скорость выполнения функции, используя инструменты Го.
Как изменится сложность алгоритма при увеличении скорости?
*/

// размер входных данных: len(a) = n
// основная операция: t1 <= t2
// зависит ли число выполняемых операция только от размера входных данных: да (пусть кол-во операций M(n))
// рекурсивное уравнение: M(n) = 2 * M(n/2) + 1 =
//                        1) M(n/2) = 2 * M(n/4) + 1
//                           M(n) = 2 * (2 * M(n/4) + 1) + 1 = 4 * M(n/4) + 3
//                        2) M(n/4) = 2 * M(n/8) + 1
//							 M(n) = 4 * (2 * M(n/8) + 1) + 3 = 8 * M(n/8) + 7
// 						  3) => M(n) = 2^k * (M(n / 2^k)) + (2^k - 1)
//                        4) n/2^k = 1 => k = log2(n)
//                        5) при подстановке k = log2(n) и T(1) = 0 (потому что при n = 1 мы сразу выйдем из функции)
//                        в уравнение M(n) = 2^k * M(1) + (2^k - 1) мы получим M(n) = n * M(1) + (n - 1) =
//							 = n * 0 + (n - 1) = n - 1
// решение или порядок роста: n

// алгоритм 2 будет быстрее на большом количестве данных, поскольку выполняет меньше операций на каждом уровне рекурсии
//(разделяет массив пополам вместо того, чтобы уменьшать его на 1 элемент каждый раз)

func MinEl2(a []int) int {
	// только для первичной проверки
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}

	t1 := MinEl2(a[:len(a)/2])
	t2 := MinEl2(a[len(a)/2:])
	if t1 <= t2 {
		return t1
	}
	return t2
}

// goos: darwin
// goarch: arm64
// pkg: inno/hw9
// BenchmarkMinEl-12                 207692              5640 ns/op               0 B/op          0 allocs/op
// BenchmarkMinEl2-12                508114              2339 ns/op               0 B/op          0 allocs/op
// BenchmarkMinElImproved-12         964018              1267 ns/op               0 B/op          0 allocs/op

// при следующем решении скорость увеличивается, но сложность алгоритма не изменится

func MinElImproved(a []int) int {
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}

	if len(a) == 2 {
		if a[0] <= a[1] {
			return a[0]
		} else {
			return a[1]
		}
	}

	t1 := MinElImproved(a[:len(a)/2])
	t2 := MinElImproved(a[len(a)/2:])

	if t1 <= t2 {
		return t1
	}
	return t2
}

// алгоритм с горутинами только замедляет работу
// BenchmarkMinElGoroutines-12         1624            698826 ns/op          341481 B/op       6054 allocs/op

func MinElGoroutines(a []int) int {
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}

	t1Chan := make(chan int)
	t2Chan := make(chan int)

	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		t1Chan <- MinElGoroutines(a[:len(a)/2])
	}()

	go func() {
		defer wg.Done()
		t2Chan <- MinElGoroutines(a[len(a)/2:])
	}()

	go func() {
		wg.Wait()
		close(t1Chan)
		close(t2Chan)
	}()

	t1 := <-t1Chan
	t2 := <-t2Chan

	if t1 <= t2 {
		return t1
	}
	return t2
}
